<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone - Three.js</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-image: url('https://yourimageshare.com/ib/H5g4mr1cNY.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
            color: white;
            padding: 0;
            border-radius: 0;
            text-align: center;
            cursor: default;
            width: 100%;
            max-width: 600px;
        }
        #instructions.hidden {
            display: none;
        }
        
        #createWorldScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
            color: white;
            padding: 0;
            text-align: center;
            width: 100%;
            max-width: 600px;
        }
        
        /* Minecraft-style menu */
        .mc-logo {
            width: 100%;
            max-width: 548px;
            margin: 0 auto 40px;
            font-size: 80px;
            font-weight: bold;
            color: white;
            text-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
            letter-spacing: 8px;
        }
        
        .mc-splash {
            position: absolute;
            top: 80px;
            right: -50px;
            transform: rotate(-20deg);
            font-size: 21px;
            text-shadow: 3px 3px 0 #4A4003;
            color: #FAFF16;
            font-weight: bold;
        }
        
        .mc-menu {
            width: 400px;
            margin: 0 auto;
        }
        
        .mc-btn {
            display: block;
            width: 100%;
            margin-bottom: 8px;
            padding: 10px;
            border: 2px solid #000;
            outline: none;
            box-shadow: inset 2px 2px 0 rgba(255, 255, 255, 0.3), 
                        inset -2px 2px 0 rgba(255, 255, 255, 0.3), 
                        inset 0px -4px 0 rgba(0, 0, 0, 0.3);
            background: #6A6A6A;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-align: center;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.5);
            letter-spacing: 0.5px;
            color: #FFF;
            cursor: pointer;
            transition: background 0.2s;
            box-sizing: border-box;
        }
        
        .mc-btn:hover:not(:disabled) {
            background: #7A7A7A;
        }
        
        .mc-btn:active:not(:disabled) {
            background: #5A5A5A;
        }
        
        .mc-seed-input {
            width: 100%;
            margin: 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #000;
            box-shadow: inset 2px 2px 0 rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 14px;
            text-align: left;
            box-sizing: border-box;
        }
        
        .mc-seed-label {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
            text-align: left;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }
        
        .mc-footer {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            width: 100%;
            font-size: 12px;
            color: white;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 1000;
        }
        
        .mc-footer > div:first-child {
            position: absolute;
            left: 10px;
            bottom: 0;
        }
        
        .mc-footer > div:last-child {
            position: absolute;
            right: 10px;
            bottom: 0;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #fileInput {
            display: none;
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px;
            border-radius: 4px;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(139, 139, 139, 0.8);
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            cursor: pointer;
            position: relative;
            transition: all 0.1s;
        }
        .hotbar-slot.active {
            border-color: white;
            background: rgba(139, 139, 139, 1);
            transform: scale(1.1);
        }
        .hotbar-slot:hover {
            background: rgba(160, 160, 160, 0.9);
        }
        .block-icon {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }
        .slot-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #ddd;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <div class="mc-logo" style="position: relative;">
            MINECRAFT
            <span class="mc-splash">With Trees!</span>
        </div>
        <div class="mc-menu">
            <button class="mc-btn" id="singleplayerButton">Singleplayer</button>
            <button class="mc-btn" id="multiplayerButton">Multiplayer</button>
            <button class="mc-btn" id="textureUpload">Options</button>
            <input type="file" id="fileInput" webkitdirectory directory multiple style="display: none;">
        </div>
    </div>
    
    <!-- Multiplayer Room Screen -->
    <div id="multiplayerScreen" style="display: none;">
        <div style="text-align: center; color: white; margin-bottom: 40px;">
            <h1 style="font-size: 32px; text-shadow: 3px 3px 0 rgba(0,0,0,0.5); margin: 0;">Multiplayer</h1>
        </div>
        <div class="mc-menu">
            <button class="mc-btn" id="joinServerButton">Join Server (WebSocket)</button>
            <button class="mc-btn" id="hostGameButton">Host Game (P2P)</button>
            <button class="mc-btn" id="joinGameButton">Join Game (P2P)</button>
            <button class="mc-btn" id="multiplayerBackButton">Back</button>
            
            <!-- WebSocket Server Input -->
            <div id="serverInput" style="display: none; margin-top: 30px;">
                <div class="mc-seed-label">WebSocket Server URL:</div>
                <input type="text" id="serverUrl" class="mc-seed-input" 
                       placeholder="wss://your-server.com" 
                       style="text-align: left; font-size: 14px;">
                <div class="mc-seed-label" style="margin-top: 10px; font-size: 11px;">
                    Enter your WebSocket server URL (e.g., wss://example.com)
                </div>
                <button class="mc-btn" id="connectServerButton" style="margin-top: 15px;">Connect to Server</button>
            </div>
            
            <div id="roomCodeDisplay" style="display: none; margin-top: 30px;">
                <div class="mc-seed-label">Your Room Code:</div>
                <input type="text" id="roomCodeText" class="mc-seed-input" readonly style="text-align: center; font-size: 20px; font-weight: bold; letter-spacing: 3px;">
                <div class="mc-seed-label" style="margin-top: 10px;">Share this code with friends!</div>
                <div class="mc-seed-label" style="margin-top: 20px; color: #4CAF50;" id="waitingText">Waiting for players...</div>
            </div>
            
            <div id="joinRoomInput" style="display: none; margin-top: 30px;">
                <div class="mc-seed-label">Enter Room Code:</div>
                <input type="text" id="joinRoomCode" class="mc-seed-input" placeholder="Enter 6-digit code" maxlength="10" style="text-align: center; font-size: 20px; text-transform: uppercase;">
                <button class="mc-btn" id="connectButton" style="margin-top: 15px;">Connect</button>
            </div>
        </div>
    </div>
    
    <!-- Create New World Screen -->
    <div id="createWorldScreen" style="display: none;">
        <div style="text-align: center; color: white; margin-bottom: 40px;">
            <h1 style="font-size: 32px; text-shadow: 3px 3px 0 rgba(0,0,0,0.5); margin: 0;">Create New World</h1>
        </div>
        <div class="mc-menu">
            <div class="mc-seed-label">Seed for the World Generator</div>
            <input type="text" id="seedInput" class="mc-seed-input" placeholder="">
            <div class="mc-seed-label" style="margin-top: 5px; margin-bottom: 30px;">Leave blank for a random seed</div>
            
            <button class="mc-btn" disabled style="opacity: 0.5; margin-bottom: 15px;">
                Generate Structures: ON
                <div style="font-size: 11px; margin-top: 3px;">Villages, dungeons etc</div>
            </button>
            
            <button class="mc-btn" disabled style="opacity: 0.5; margin-bottom: 15px;">
                World Type: Default
            </button>
            
            <button class="mc-btn" disabled style="opacity: 0.5; margin-bottom: 15px;">
                Allow Cheats: OFF
                <div style="font-size: 11px; margin-top: 3px;">Commands like /gamemode, /xp</div>
            </button>
            
            <button class="mc-btn" disabled style="opacity: 0.5; margin-bottom: 40px;">
                Bonus Chest: OFF
            </button>
            
            <button class="mc-btn" id="createWorldButton">Create New World</button>
            
            <button class="mc-btn" id="cancelButton">Cancel</button>
        </div>
    </div>
    
    <!-- Pause Menu (appears when pressing ESC during game) -->
    <div id="pauseMenu" style="display: none;">
        <div style="text-align: center; color: white; margin-bottom: 40px;">
            <h1 style="font-size: 32px; text-shadow: 3px 3px 0 rgba(0,0,0,0.5); margin: 0;">Game Paused</h1>
        </div>
        <div class="mc-menu">
            <button class="mc-btn" id="resumeGameButton">Back to Game</button>
            <button class="mc-btn" id="pauseTextureUpload">Upload Texture Pack</button>
            <button class="mc-btn" id="exportWorldButton">Export World Data</button>
            <button class="mc-btn" id="importWorldButton">Import World Data</button>
            <button class="mc-btn" id="saveWorldButton" disabled style="opacity: 0.5;">Save and Quit to Title</button>
        </div>
    </div>
    
    <!-- Hidden file input for importing world data -->
    <input type="file" id="worldImportInput" accept=".json" style="display: none;">
    
    <div id="crosshair"></div>
    
    <!-- Footer - Always visible -->
    <div class="mc-footer">
        <div>Minecraft Clone v1.0</div>
        <div>Made with Three.js</div>
    </div>
    
    <div id="hotbar">
        <div class="hotbar-slot active" data-block="grass" title="Grass Block">
            <span class="slot-number">1</span>
            <div class="block-icon" id="grass-icon" style="background: linear-gradient(to bottom, #4CAF50 0%, #4CAF50 50%, #5CBF60 50%, #5CBF60 100%);"></div>
        </div>
        <div class="hotbar-slot" data-block="dirt" title="Dirt Block">
            <span class="slot-number">2</span>
            <div class="block-icon" id="dirt-icon" style="background: #8B4513;"></div>
        </div>
        <div class="hotbar-slot" data-block="stone" title="Stone Block">
            <span class="slot-number">3</span>
            <div class="block-icon" id="stone-icon" style="background: #808080;"></div>
        </div>
        <div class="hotbar-slot" data-block="custom" title="Custom Block - Click to upload">
            <span class="slot-number">4</span>
            <div class="block-icon" id="custom-icon" style="background: linear-gradient(45deg, #444 25%, #666 25%, #666 50%, #444 50%, #444 75%, #666 75%); background-size: 8px 8px;">+</div>
        </div>
    </div>
    <input type="file" id="customBlockInput" accept="image/*" style="display: none;">
    <div id="info">
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>Seed: <span id="seedDisplay">-</span></div>
        <div>Chunks: <span id="chunks">0</span></div>
        <div>Blocks: <span id="blockCount">0</span></div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
            <label for="renderDistance" style="display: block; font-size: 11px; margin-bottom: 5px;">
                Render Distance: <span id="renderDistanceValue">2</span> chunks
            </label>
            <input type="range" id="renderDistance" min="2" max="8" value="2" step="1" 
                   style="width: 100%; cursor: pointer;">
            <div style="font-size: 10px; color: #aaa; margin-top: 3px;">
                (2=tiny, 4=normal, 8=far)
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // World seed system
        let worldSeed = 0;
        
        // Multiplayer system
        let peer = null;
        let isHost = false;
        let connections = [];
        let isMultiplayer = false;
        let otherPlayers = new Map(); // Map of peerId -> player object with mesh
        
        // WebSocket multiplayer
        let ws = null;
        let isWebSocketMode = false;
        let myPlayerId = null;
        
        // WebSocket connection function
        function connectToWebSocketServer(serverUrl) {
            try {
                ws = new WebSocket(serverUrl);
                isWebSocketMode = true;
                isMultiplayer = true;
                
                ws.onopen = () => {
                    console.log('Connected to WebSocket server:', serverUrl);
                    
                    // Send join message
                    ws.send(JSON.stringify({
                        type: 'join',
                        seed: worldSeed
                    }));
                    
                    // Hide multiplayer screen and show create world screen
                    document.getElementById('multiplayerScreen').style.display = 'none';
                    document.getElementById('createWorldScreen').style.display = 'block';
                    
                    alert('Connected to server! Create your world to start playing.');
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    alert('Failed to connect to server. Please check the URL and try again.');
                    isWebSocketMode = false;
                    isMultiplayer = false;
                };
                
                ws.onclose = () => {
                    console.log('Disconnected from server');
                    isWebSocketMode = false;
                    isMultiplayer = false;
                    
                    // Remove all other players
                    otherPlayers.forEach((playerData, id) => {
                        scene.remove(playerData.mesh);
                    });
                    otherPlayers.clear();
                };
            } catch (error) {
                alert('Invalid server URL: ' + error.message);
            }
        }
        
        // Handle WebSocket messages
        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'welcome':
                    myPlayerId = data.playerId;
                    console.log('Assigned player ID:', myPlayerId);
                    
                    // Use the server's world seed
                    if (data.seed !== undefined) {
                        worldSeed = data.seed;
                        document.getElementById('seedInput').value = worldSeed;
                        console.log('Received world seed from server:', worldSeed);
                        
                        // Auto-hide multiplayer screen and show create world screen
                        document.getElementById('multiplayerScreen').style.display = 'none';
                        document.getElementById('createWorldScreen').style.display = 'block';
                    }
                    break;
                    
                case 'playerJoined':
                    console.log('Player joined:', data.playerId);
                    createOtherPlayer(data.playerId);
                    break;
                    
                case 'playerLeft':
                    console.log('Player left:', data.playerId);
                    removeOtherPlayer(data.playerId);
                    break;
                    
                case 'playerMove':
                    if (data.playerId !== myPlayerId) {
                        const playerData = otherPlayers.get(data.playerId);
                        if (playerData) {
                            playerData.mesh.position.set(data.x, data.y, data.z);
                            playerData.position = { x: data.x, y: data.y, z: data.z };
                        } else {
                            createOtherPlayer(data.playerId);
                        }
                    }
                    break;
                    
                case 'blockPlace':
                    if (data.playerId !== myPlayerId) {
                        const newBlock = new THREE.Mesh(blockGeometry, getBlockMaterial(data.blockType));
                        newBlock.position.set(data.x, data.y, data.z);
                        newBlock.userData.blockType = data.blockType;
                        newBlock.userData.isPlayerPlaced = true;
                        newBlock.frustumCulled = true;
                        scene.add(newBlock);
                        blocks.push(newBlock);
                    }
                    break;
                    
                case 'blockBreak':
                    if (data.playerId !== myPlayerId) {
                        const blockToRemove = blocks.find(b => 
                            Math.abs(b.position.x - data.x) < 0.1 && 
                            Math.abs(b.position.y - data.y) < 0.1 && 
                            Math.abs(b.position.z - data.z) < 0.1
                        );
                        if (blockToRemove) {
                            scene.remove(blockToRemove);
                            const index = blocks.indexOf(blockToRemove);
                            if (index > -1) blocks.splice(index, 1);
                        }
                    }
                    break;
            }
        }
        
        // Send message via WebSocket
        function sendWebSocketMessage(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    ...data,
                    playerId: myPlayerId
                }));
            }
        }
        
        // Initialize PeerJS (for P2P mode)
        function initMultiplayer() {
            peer = new Peer({
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('open', (id) => {
                console.log('My peer ID:', id);
            });
            
            peer.on('error', (err) => {
                console.error('Peer error:', err);
                alert('Connection error: ' + err.type);
            });
        }
        
        // Host a game
        function hostGame() {
            isHost = true;
            isMultiplayer = true;
            initMultiplayer();
            
            peer.on('open', (id) => {
                const roomCode = id.substring(0, 6).toUpperCase();
                document.getElementById('roomCodeText').value = roomCode;
                document.getElementById('roomCodeDisplay').style.display = 'block';
                document.getElementById('hostGameButton').style.display = 'none';
                document.getElementById('joinGameButton').style.display = 'none';
                
                console.log('Hosting with room code:', roomCode);
            });
            
            peer.on('connection', (conn) => {
                console.log('Player connected:', conn.peer);
                connections.push(conn);
                
                conn.on('open', () => {
                    // Send current world state to new player
                    conn.send({
                        type: 'init',
                        seed: worldSeed,
                        playerPos: {
                            x: player.position.x,
                            y: player.position.y,
                            z: player.position.z
                        }
                    });
                    
                    // Create player mesh for this connection
                    createOtherPlayer(conn.peer);
                });
                
                conn.on('data', (data) => {
                    handleMultiplayerData(data, conn.peer);
                });
                
                conn.on('close', () => {
                    console.log('Player disconnected:', conn.peer);
                    removeOtherPlayer(conn.peer);
                    connections = connections.filter(c => c !== conn);
                });
            });
        }
        
        // Join a game
        function joinGame(roomCode) {
            isHost = false;
            isMultiplayer = true;
            initMultiplayer();
            
            peer.on('open', (id) => {
                // Try to connect using the room code
                const fullPeerId = roomCode.toLowerCase();
                const conn = peer.connect(fullPeerId, {reliable: true});
                
                conn.on('open', () => {
                    console.log('Connected to host!');
                    connections.push(conn);
                    
                    // Hide multiplayer screen and show create world screen
                    document.getElementById('multiplayerScreen').style.display = 'none';
                    document.getElementById('createWorldScreen').style.display = 'block';
                });
                
                conn.on('data', (data) => {
                    handleMultiplayerData(data, conn.peer);
                });
                
                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                    alert('Could not connect to room. Check the code and try again.');
                });
            });
        }
        
        // Create visual representation of other players
        function createOtherPlayer(peerId) {
            // Create a simple colored cube for other players
            const geometry = new THREE.BoxGeometry(0.6, 1.8, 0.6);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() * 0xffffff 
            });
            const playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.position.set(0, 10, 0);
            scene.add(playerMesh);
            
            otherPlayers.set(peerId, {
                mesh: playerMesh,
                position: { x: 0, y: 10, z: 0 }
            });
        }
        
        // Remove other player
        function removeOtherPlayer(peerId) {
            const playerData = otherPlayers.get(peerId);
            if (playerData) {
                scene.remove(playerData.mesh);
                otherPlayers.delete(peerId);
            }
        }
        
        // Handle incoming multiplayer data
        function handleMultiplayerData(data, fromPeer) {
            if (data.type === 'init') {
                // Received world initialization
                worldSeed = data.seed;
                console.log('Received world seed:', worldSeed);
                createOtherPlayer(fromPeer);
            } else if (data.type === 'playerMove') {
                // Update other player position
                const playerData = otherPlayers.get(fromPeer);
                if (playerData) {
                    playerData.mesh.position.set(data.x, data.y, data.z);
                    playerData.position = { x: data.x, y: data.y, z: data.z };
                }
            } else if (data.type === 'blockPlace') {
                // Another player placed a block
                const newBlock = new THREE.Mesh(blockGeometry, getBlockMaterial(data.blockType));
                newBlock.position.set(data.x, data.y, data.z);
                newBlock.userData.blockType = data.blockType;
                newBlock.userData.isPlayerPlaced = true;
                newBlock.frustumCulled = true;
                scene.add(newBlock);
                blocks.push(newBlock);
            } else if (data.type === 'blockBreak') {
                // Another player broke a block
                const blockToRemove = blocks.find(b => 
                    Math.abs(b.position.x - data.x) < 0.1 && 
                    Math.abs(b.position.y - data.y) < 0.1 && 
                    Math.abs(b.position.z - data.z) < 0.1
                );
                if (blockToRemove) {
                    scene.remove(blockToRemove);
                    const index = blocks.indexOf(blockToRemove);
                    if (index > -1) blocks.splice(index, 1);
                }
            }
        }
        
        // Broadcast to all connected players (supports both WebSocket and P2P)
        function broadcastToAll(data) {
            if (!isMultiplayer) return;
            
            // WebSocket mode
            if (isWebSocketMode && ws && ws.readyState === WebSocket.OPEN) {
                sendWebSocketMessage(data);
            }
            
            // P2P mode
            connections.forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }
        
        // Send player position updates (called in animation loop)
        let lastPositionUpdate = 0;
        function sendPlayerPosition() {
            if (!isMultiplayer) return;
            
            const now = Date.now();
            if (now - lastPositionUpdate > 50) { // Update 20 times per second
                const data = {
                    type: 'playerMove',
                    x: player.position.x,
                    y: player.position.y,
                    z: player.position.z
                };
                
                // WebSocket mode
                if (isWebSocketMode) {
                    sendWebSocketMessage(data);
                }
                
                // P2P mode
                broadcastToAll(data);
                
                lastPositionUpdate = now;
            }
        }
        
        // Simple hash function to convert string seed to number
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }
        
        // Seeded random number generator (LCG - Linear Congruential Generator)
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 1664525 + 1013904223) % 4294967296;
                return state / 4294967296;
            };
        }
        
        // Seeded noise function for terrain generation
        function seededNoise(x, z, seed) {
            // Use seed to modify the noise pattern
            const n = Math.sin(x * 12.9898 + z * 78.233 + seed) * 43758.5453123;
            return n - Math.floor(n);
        }
        
        // Improved perlin-like noise for smoother terrain
        function smoothNoise(x, z, seed) {
            // Get integer and fractional parts
            const intX = Math.floor(x);
            const intZ = Math.floor(z);
            const fracX = x - intX;
            const fracZ = z - intZ;
            
            // Get noise at corners
            const v1 = seededNoise(intX, intZ, seed);
            const v2 = seededNoise(intX + 1, intZ, seed);
            const v3 = seededNoise(intX, intZ + 1, seed);
            const v4 = seededNoise(intX + 1, intZ + 1, seed);
            
            // Smooth interpolation
            const i1 = v1 * (1 - fracX) + v2 * fracX;
            const i2 = v3 * (1 - fracX) + v4 * fracX;
            
            return i1 * (1 - fracZ) + i2 * fracZ;
        }
        
        // Get height at position using seed
        function getTerrainHeight(x, z) {
            // Use smoother noise with better scales for natural terrain
            const scale1 = 0.02; // Large features (hills)
            const scale2 = 0.08; // Medium features
            const scale3 = 0.15; // Small details
            
            const noise1 = smoothNoise(x * scale1, z * scale1, worldSeed) * 6;
            const noise2 = smoothNoise(x * scale2, z * scale2, worldSeed + 1000) * 3;
            const noise3 = smoothNoise(x * scale3, z * scale3, worldSeed + 2000) * 1.5;
            
            const height = Math.floor(noise1 + noise2 + noise3);
            return height;
        }
        
        // Initialize seed from input or generate random
        function initializeSeed() {
            const seedInput = document.getElementById('seedInput');
            const seedValue = seedInput.value.trim();
            
            if (seedValue === '') {
                // Generate random seed
                worldSeed = Math.floor(Math.random() * 1000000);
                console.log(`Generated random seed: ${worldSeed}`);
            } else {
                // Use provided seed (convert to number if string)
                if (isNaN(seedValue)) {
                    worldSeed = hashString(seedValue);
                    console.log(`Using text seed: "${seedValue}" â†’ ${worldSeed}`);
                } else {
                    worldSeed = parseInt(seedValue);
                    console.log(`Using numeric seed: ${worldSeed}`);
                }
            }
            
            // Display seed in console for user to save
            console.log(`World Seed: ${worldSeed} (save this to recreate the world!)`);
        }
        
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 0, 50); // Match default 2 chunk render distance

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; // DISABLED for performance
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = false; // Disabled for performance
        scene.add(directionalLight);

        // Textures for blocks
        const textureLoader = new THREE.TextureLoader();
        
        // Create simple colored materials for different block types
        let grassTopMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
        let grassSideMaterial = new THREE.MeshLambertMaterial({ color: 0x5CBF60 });
        let dirtMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        let stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
        let customMaterial = new THREE.MeshLambertMaterial({ color: 0xFF00FF }); // Custom block default
        let woodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown wood
        let leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22, transparent: true, opacity: 0.9 }); // Green leaves

        // Texture pack upload functionality
        const textureUpload = document.getElementById('textureUpload');
        const fileInput = document.getElementById('fileInput');

        // Function to update hotbar icon
        function updateHotbarIcon(blockType, imageUrl) {
            const iconId = blockType + '-icon';
            const icon = document.getElementById(iconId);
            if (icon) {
                icon.style.backgroundImage = `url(${imageUrl})`;
                icon.style.backgroundSize = 'cover';
                icon.textContent = ''; // Remove the + sign for custom
            }
        }

        textureUpload.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            const textureMap = {};

            files.forEach(file => {
                // Only process image files
                if (!file.type.startsWith('image/')) return;
                
                const fileName = file.name.toLowerCase();
                if (fileName.includes('grasstop') || fileName.includes('grass_top')) {
                    textureMap.grasstop = file;
                } else if (fileName.includes('grass')) {
                    textureMap.grass = file;
                } else if (fileName.includes('dirt')) {
                    textureMap.dirt = file;
                } else if (fileName.includes('stone')) {
                    textureMap.stone = file;
                }
            });

            // Load and apply textures
            Object.keys(textureMap).forEach(type => {
                const file = textureMap[type];
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    const imageUrl = event.target.result;
                    
                    textureLoader.load(imageUrl, (texture) => {
                        texture.magFilter = THREE.NearestFilter;
                        texture.minFilter = THREE.NearestFilter;
                        
                        let newMaterial = new THREE.MeshLambertMaterial({ map: texture });
                        
                        if (type === 'grasstop') {
                            grassTopMaterial = newMaterial;
                            // Update existing grass blocks (top faces)
                            blocks.forEach(block => {
                                if (block.userData.blockType === 'grass' && Array.isArray(block.material)) {
                                    block.material[2] = grassTopMaterial; // Top face
                                }
                            });
                            // Update grass icon (use grasstop for icon)
                            updateHotbarIcon('grass', imageUrl);
                        } else if (type === 'grass') {
                            grassSideMaterial = newMaterial;
                            // Update existing grass blocks (side faces)
                            blocks.forEach(block => {
                                if (block.userData.blockType === 'grass' && Array.isArray(block.material)) {
                                    block.material[0] = grassSideMaterial;
                                    block.material[1] = grassSideMaterial;
                                    block.material[4] = grassSideMaterial;
                                    block.material[5] = grassSideMaterial;
                                }
                            });
                        } else if (type === 'dirt') {
                            dirtMaterial = newMaterial;
                            // Update existing dirt blocks
                            blocks.forEach(block => {
                                if (block.userData.blockType === 'dirt') {
                                    block.material = [newMaterial, newMaterial, newMaterial, newMaterial, newMaterial, newMaterial];
                                }
                            });
                            // Update dirt icon
                            updateHotbarIcon('dirt', imageUrl);
                        } else if (type === 'stone') {
                            stoneMaterial = newMaterial;
                            // Update existing stone blocks
                            blocks.forEach(block => {
                                if (block.userData.blockType === 'stone') {
                                    block.material = [newMaterial, newMaterial, newMaterial, newMaterial, newMaterial, newMaterial];
                                }
                            });
                            // Update stone icon
                            updateHotbarIcon('stone', imageUrl);
                        }

                        console.log(`Loaded ${type} texture from ${file.name}`);
                    });
                };
                
                reader.readAsDataURL(file);
            });

            // Show feedback
            if (Object.keys(textureMap).length > 0) {
                alert(`Loaded ${Object.keys(textureMap).length} texture(s)!`);
            } else {
                alert('No valid textures found. Please upload files named grasstop.png, grass.png, dirt.png, or stone.png');
            }

            fileInput.value = ''; // Reset input
        });

        // Helper function to create grass block material array
        function createGrassMaterials() {
            return [
                grassSideMaterial, // Right
                grassSideMaterial, // Left
                grassTopMaterial,  // Top
                dirtMaterial,      // Bottom
                grassSideMaterial, // Front
                grassSideMaterial  // Back
            ];
        }

        // Chunk-based optimization system (like Eaglercraft/Minecraft)
        const CHUNK_SIZE = 16; // Standard Minecraft chunk size
        let RENDER_DISTANCE = 2; // Reduced to 2 for better performance (2 chunks = 32 blocks)
        const chunks = new Map();
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

        // Render distance slider
        const renderDistanceSlider = document.getElementById('renderDistance');
        const renderDistanceValue = document.getElementById('renderDistanceValue');

        // Tree generation helper function
        function generateTree(x, y, z, chunk) {
            const treeHeight = 4 + Math.floor(Math.random() * 2); // 4-5 blocks tall
            const treeBlocks = [];
            
            // Generate trunk (wood blocks)
            for (let i = 0; i < treeHeight; i++) {
                const woodBlock = new THREE.Mesh(blockGeometry, woodMaterial);
                woodBlock.position.set(x, y + i, z);
                woodBlock.userData.blockType = 'wood';
                woodBlock.userData.chunk = chunk;
                woodBlock.frustumCulled = true;
                scene.add(woodBlock);
                blocks.push(woodBlock);
                chunk.addBlock(woodBlock);
                treeBlocks.push(woodBlock);
            }
            
            // Generate leaves (3x3x3 cube at top)
            const leavesY = y + treeHeight;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    for (let dy = 0; dy <= 2; dy++) {
                        // Skip the center column where trunk is (except top)
                        if (dx === 0 && dz === 0 && dy < 2) continue;
                        
                        // Add some randomness - skip some leaf blocks
                        if (Math.random() > 0.85) continue;
                        
                        const leafBlock = new THREE.Mesh(blockGeometry, leavesMaterial);
                        leafBlock.position.set(x + dx, leavesY + dy, z + dz);
                        leafBlock.userData.blockType = 'leaves';
                        leafBlock.userData.chunk = chunk;
                        leafBlock.frustumCulled = true;
                        scene.add(leafBlock);
                        blocks.push(leafBlock);
                        chunk.addBlock(leafBlock);
                        treeBlocks.push(leafBlock);
                    }
                }
            }
            
            return treeBlocks;
        }

        renderDistanceSlider.addEventListener('input', (e) => {
            RENDER_DISTANCE = parseInt(e.target.value);
            renderDistanceValue.textContent = RENDER_DISTANCE;
            
            // Immediately update chunks with new render distance (if player exists)
            if (typeof player !== 'undefined') {
                updateChunks(player.position.x, player.position.z);
            } else {
                // Update from spawn point if player doesn't exist yet
                updateChunks(0, 0);
            }
            
            // Update fog distance to match
            const fogDistance = RENDER_DISTANCE * CHUNK_SIZE + 20;
            scene.fog.far = fogDistance;
            
            console.log(`Render distance changed to ${RENDER_DISTANCE} chunks (${RENDER_DISTANCE * 16} blocks)`);
        });

        class Chunk {
            constructor(chunkX, chunkZ) {
                this.chunkX = chunkX;
                this.chunkZ = chunkZ;
                this.blocks = [];
                this.mesh = null;
                this.needsUpdate = true;
                this.generated = false;
            }

            addBlock(block) {
                this.blocks.push(block);
                this.needsUpdate = true;
            }

            removeBlock(block) {
                const index = this.blocks.indexOf(block);
                if (index > -1) {
                    this.blocks.splice(index, 1);
                    this.needsUpdate = true;
                }
            }

            // Generate terrain for this chunk - INSTANT generation
            generate() {
                if (this.generated) return;
                
                const startX = this.chunkX * CHUNK_SIZE;
                const startZ = this.chunkZ * CHUNK_SIZE;
                
                // Store tree positions for this chunk
                const treePositions = [];
                
                // Generate all blocks at once - no delays
                for (let x = startX; x < startX + CHUNK_SIZE; x++) {
                    for (let z = startZ; z < startZ + CHUNK_SIZE; z++) {
                        // Use seeded height generation
                        const height = getTerrainHeight(x, z);
                        
                        // Create grass block on top
                        const grassBlock = new THREE.Mesh(blockGeometry, createGrassMaterials());
                        grassBlock.position.set(x, height, z);
                        grassBlock.userData.blockType = 'grass';
                        grassBlock.userData.chunk = this;
                        grassBlock.frustumCulled = true;
                        scene.add(grassBlock);
                        blocks.push(grassBlock);
                        this.addBlock(grassBlock);

                        // One dirt layer below
                        const dirtBlock = new THREE.Mesh(blockGeometry, dirtMaterial);
                        dirtBlock.position.set(x, height - 1, z);
                        dirtBlock.userData.blockType = 'dirt';
                        dirtBlock.userData.chunk = this;
                        dirtBlock.frustumCulled = true;
                        scene.add(dirtBlock);
                        blocks.push(dirtBlock);
                        this.addBlock(dirtBlock);

                        // One stone layer below dirt
                        const stoneBlock = new THREE.Mesh(blockGeometry, stoneMaterial);
                        stoneBlock.position.set(x, height - 2, z);
                        stoneBlock.userData.blockType = 'stone';
                        stoneBlock.userData.chunk = this;
                        stoneBlock.frustumCulled = true;
                        scene.add(stoneBlock);
                        blocks.push(stoneBlock);
                        this.addBlock(stoneBlock);
                        
                        // Randomly decide if a tree should spawn here
                        // Use seeded random based on position
                        const treeRandom = seededNoise(x, z, worldSeed + 9999);
                        // Trees spawn with ~3% chance, only on grass, not too close to chunk edges
                        if (treeRandom > 0.97 && 
                            x > startX + 2 && x < startX + CHUNK_SIZE - 2 &&
                            z > startZ + 2 && z < startZ + CHUNK_SIZE - 2) {
                            treePositions.push({ x, y: height + 1, z });
                        }
                    }
                }
                
                // Generate trees after terrain is complete
                treePositions.forEach(pos => {
                    generateTree(pos.x, pos.y, pos.z, this);
                });
                
                this.generated = true;
            }

            // Unload chunk (remove all blocks from scene)
            unload() {
                this.blocks.forEach(block => {
                    scene.remove(block);
                    const index = blocks.indexOf(block);
                    if (index > -1) {
                        blocks.splice(index, 1);
                    }
                });
                this.blocks = [];
                this.generated = false;
            }

            // Merge visible blocks into a single geometry for better performance
            buildMesh() {
                if (!this.needsUpdate) return;
                
                // Remove old mesh if exists
                if (this.mesh) {
                    scene.remove(this.mesh);
                }

                // Only build if there are blocks
                if (this.blocks.length === 0) {
                    this.needsUpdate = false;
                    return;
                }

                this.needsUpdate = false;
            }

            getDistance(chunkX, chunkZ) {
                return Math.max(Math.abs(this.chunkX - chunkX), Math.abs(this.chunkZ - chunkZ));
            }
        }

        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }

        function worldToChunk(x, z) {
            return {
                chunkX: Math.floor(x / CHUNK_SIZE),
                chunkZ: Math.floor(z / CHUNK_SIZE)
            };
        }

        function getOrCreateChunk(chunkX, chunkZ) {
            const key = getChunkKey(chunkX, chunkZ);
            if (!chunks.has(key)) {
                chunks.set(key, new Chunk(chunkX, chunkZ));
            }
            return chunks.get(key);
        }

        // Dynamic chunk loading/unloading - INSTANT (no delays)
        let isLoadingChunks = false;
        
        function updateChunks(playerX, playerZ) {
            if (isLoadingChunks) return; // Don't start new load if already loading
            isLoadingChunks = true;
            
            const playerChunk = worldToChunk(playerX, playerZ);
            const loadedChunks = new Set();
            const chunksToGenerate = [];
            
            // Find chunks that need to be loaded
            for (let x = playerChunk.chunkX - RENDER_DISTANCE; x <= playerChunk.chunkX + RENDER_DISTANCE; x++) {
                for (let z = playerChunk.chunkZ - RENDER_DISTANCE; z <= playerChunk.chunkZ + RENDER_DISTANCE; z++) {
                    const key = getChunkKey(x, z);
                    loadedChunks.add(key);
                    
                    const chunk = getOrCreateChunk(x, z);
                    if (!chunk.generated) {
                        chunksToGenerate.push(chunk);
                    }
                }
            }
            
            // Generate ALL chunks INSTANTLY - no delays
            for (const chunk of chunksToGenerate) {
                chunk.generate();
            }
            
            // Unload chunks that are too far away - MORE AGGRESSIVE
            const chunksToUnload = [];
            chunks.forEach((chunk, key) => {
                if (!loadedChunks.has(key)) {
                    const distance = chunk.getDistance(playerChunk.chunkX, playerChunk.chunkZ);
                    // Unload immediately when beyond render distance (was +2, now +1)
                    if (distance > RENDER_DISTANCE + 1) {
                        chunksToUnload.push(key);
                    }
                }
            });
            
            // Unload distant chunks
            chunksToUnload.forEach(key => {
                const chunk = chunks.get(key);
                if (chunk) {
                    chunk.unload();
                    chunks.delete(key);
                }
            });
            
            isLoadingChunks = false;
        }

        // Initialize terrain - load initial chunks around spawn
        const blocks = [];
        
        // Track player-placed and player-removed blocks for import/export
        const playerModifications = {
            placed: [], // {x, y, z, blockType}
            removed: []  // {x, y, z}
        };
        
        // Hotbar system
        let selectedBlockType = 'grass';
        const hotbarSlots = document.querySelectorAll('.hotbar-slot');
        const customBlockInput = document.getElementById('customBlockInput');

        // Custom block upload
        customBlockInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/')) {
                alert('Please upload a valid image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                const imageUrl = event.target.result;
                
                textureLoader.load(imageUrl, (texture) => {
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    
                    customMaterial = new THREE.MeshLambertMaterial({ map: texture });
                    
                    // Update custom block icon
                    updateHotbarIcon('custom', imageUrl);
                    
                    // Update existing custom blocks
                    blocks.forEach(block => {
                        if (block.userData.blockType === 'custom') {
                            block.material = customMaterial;
                        }
                    });
                    
                    console.log(`Loaded custom block texture: ${file.name}`);
                    alert('Custom block texture loaded!');
                });
            };
            reader.readAsDataURL(file);
            customBlockInput.value = ''; // Reset input
        });

        function setSelectedBlock(blockType) {
            selectedBlockType = blockType;
            hotbarSlots.forEach(slot => {
                if (slot.dataset.block === blockType) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            });
        }

        // Hotbar click handlers
        hotbarSlots.forEach(slot => {
            slot.addEventListener('click', () => {
                // If clicking custom block slot, open file picker
                if (slot.dataset.block === 'custom') {
                    customBlockInput.click();
                }
                setSelectedBlock(slot.dataset.block);
            });
        });

        // Mouse wheel to change selected block
        document.addEventListener('wheel', (e) => {
            if (!isPointerLocked) return;
            e.preventDefault();
            
            const blockTypes = ['grass', 'dirt', 'stone', 'custom'];
            const currentIndex = blockTypes.indexOf(selectedBlockType);
            
            if (e.deltaY > 0) {
                // Scroll down
                const newIndex = (currentIndex + 1) % blockTypes.length;
                setSelectedBlock(blockTypes[newIndex]);
            } else {
                // Scroll up
                const newIndex = (currentIndex - 1 + blockTypes.length) % blockTypes.length;
                setSelectedBlock(blockTypes[newIndex]);
            }
        }, { passive: false });

        // Number key handlers (1, 2, 3, 4)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Digit1') setSelectedBlock('grass');
            else if (e.code === 'Digit2') setSelectedBlock('dirt');
            else if (e.code === 'Digit3') setSelectedBlock('stone');
            else if (e.code === 'Digit4') setSelectedBlock('custom');
        });

        // Helper function to get material for selected block type
        function getBlockMaterial(blockType) {
            if (blockType === 'grass') {
                return createGrassMaterials();
            } else if (blockType === 'dirt') {
                return dirtMaterial;
            } else if (blockType === 'stone') {
                return stoneMaterial;
            } else if (blockType === 'custom') {
                return customMaterial;
            }
            return createGrassMaterials();
        }
        
        // Don't load initial chunks yet - wait for game to start with seed
        let initialChunksLoaded = false;

        // Update chunk visibility every 30 frames for performance
        let frameCount = 0;
        let lastChunkUpdatePos = { x: 0, z: 0 };

        // Player setup
        const player = {
            position: new THREE.Vector3(0, 10, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0, z: 0 },
            height: 1.8,
            speed: 0.1,
            sprintMultiplier: 1.5,
            jumpPower: 0.15,
            onGround: false,
            isSprinting: false
        };

        camera.position.copy(player.position);
        camera.position.y += player.height;

        // Input handling
        const keys = {};
        const mouse = { x: 0, y: 0 };
        let isPointerLocked = false;

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'ShiftLeft') player.isSprinting = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'ShiftLeft') player.isSprinting = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;
            
            mouse.x = e.movementX || 0;
            mouse.y = e.movementY || 0;
        });

        // Pointer lock
        const instructions = document.getElementById('instructions');
        const createWorldScreen = document.getElementById('createWorldScreen');
        const multiplayerScreen = document.getElementById('multiplayerScreen');
        const pauseMenu = document.getElementById('pauseMenu');
        const seedInput = document.getElementById('seedInput');
        const singleplayerButton = document.getElementById('singleplayerButton');
        const multiplayerButton = document.getElementById('multiplayerButton');
        const createWorldButton = document.getElementById('createWorldButton');
        const cancelButton = document.getElementById('cancelButton');
        const hostGameButton = document.getElementById('hostGameButton');
        const joinGameButton = document.getElementById('joinGameButton');
        const multiplayerBackButton = document.getElementById('multiplayerBackButton');
        const connectButton = document.getElementById('connectButton');
        const resumeGameButton = document.getElementById('resumeGameButton');
        const pauseTextureUpload = document.getElementById('pauseTextureUpload');
        const joinServerButton = document.getElementById('joinServerButton');
        const connectServerButton = document.getElementById('connectServerButton');
        
        // Prevent seed input from starting the game
        seedInput.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Singleplayer button shows create world screen
        singleplayerButton.addEventListener('click', () => {
            isMultiplayer = false;
            isWebSocketMode = false;
            instructions.style.display = 'none';
            createWorldScreen.style.display = 'block';
        });
        
        // Multiplayer button shows multiplayer screen
        multiplayerButton.addEventListener('click', () => {
            instructions.style.display = 'none';
            multiplayerScreen.style.display = 'block';
        });
        
        // Join Server (WebSocket) button
        joinServerButton.addEventListener('click', () => {
            document.getElementById('serverInput').style.display = 'block';
            document.getElementById('hostGameButton').style.display = 'none';
            document.getElementById('joinGameButton').style.display = 'none';
        });
        
        // Connect to WebSocket server
        connectServerButton.addEventListener('click', () => {
            const serverUrl = document.getElementById('serverUrl').value.trim();
            if (!serverUrl) {
                alert('Please enter a server URL');
                return;
            }
            if (!serverUrl.startsWith('ws://') && !serverUrl.startsWith('wss://')) {
                alert('Server URL must start with ws:// or wss://');
                return;
            }
            connectToWebSocketServer(serverUrl);
        });
        
        // Multiplayer button shows multiplayer screen
        multiplayerButton.addEventListener('click', () => {
            instructions.style.display = 'none';
            multiplayerScreen.style.display = 'block';
        });
        
        // Host game button
        hostGameButton.addEventListener('click', () => {
            hostGame();
            // After hosting, show create world screen
            setTimeout(() => {
                multiplayerScreen.style.display = 'none';
                createWorldScreen.style.display = 'block';
            }, 500);
        });
        
        // Join game button
        joinGameButton.addEventListener('click', () => {
            document.getElementById('joinRoomInput').style.display = 'block';
            document.getElementById('hostGameButton').style.display = 'none';
            document.getElementById('joinGameButton').style.display = 'none';
        });
        
        // Connect to room button
        connectButton.addEventListener('click', () => {
            const roomCode = document.getElementById('joinRoomCode').value.trim();
            if (roomCode.length >= 4) {
                joinGame(roomCode);
            } else {
                alert('Please enter a valid room code');
            }
        });
        
        // Multiplayer back button
        multiplayerBackButton.addEventListener('click', () => {
            multiplayerScreen.style.display = 'none';
            instructions.style.display = 'block';
            // Reset multiplayer UI
            document.getElementById('roomCodeDisplay').style.display = 'none';
            document.getElementById('joinRoomInput').style.display = 'none';
            document.getElementById('serverInput').style.display = 'none';
            document.getElementById('hostGameButton').style.display = 'block';
            document.getElementById('joinGameButton').style.display = 'block';
        });
        
        // Cancel button goes back to main menu
        cancelButton.addEventListener('click', () => {
            createWorldScreen.style.display = 'none';
            instructions.style.display = 'block';
        });
        
        // Resume game button
        resumeGameButton.addEventListener('click', () => {
            document.body.requestPointerLock();
        });
        
        // Pause menu texture upload button
        pauseTextureUpload.addEventListener('click', () => {
            fileInput.click();
        });
        
        // Export world data button
        const exportWorldButton = document.getElementById('exportWorldButton');
        exportWorldButton.addEventListener('click', () => {
            const worldData = {
                seed: worldSeed,
                placed: playerModifications.placed,
                removed: playerModifications.removed,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(worldData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `minecraft-world-${worldSeed}-${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            alert('World data exported! You can import it later to restore your changes.');
        });
        
        // Import world data button
        const importWorldButton = document.getElementById('importWorldButton');
        const worldImportInput = document.getElementById('worldImportInput');
        
        importWorldButton.addEventListener('click', () => {
            worldImportInput.click();
        });
        
        worldImportInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const worldData = JSON.parse(event.target.result);
                    
                    // Check if seed matches (optional warning)
                    if (worldData.seed !== worldSeed) {
                        const proceed = confirm(
                            `Warning: This world data is from seed ${worldData.seed}, ` +
                            `but current world is seed ${worldSeed}. ` +
                            `Blocks may not align correctly. Import anyway?`
                        );
                        if (!proceed) return;
                    }
                    
                    // Apply removed blocks (delete them)
                    worldData.removed.forEach(pos => {
                        const blockToRemove = blocks.find(b => 
                            Math.abs(b.position.x - pos.x) < 0.1 &&
                            Math.abs(b.position.y - pos.y) < 0.1 &&
                            Math.abs(b.position.z - pos.z) < 0.1
                        );
                        if (blockToRemove) {
                            scene.remove(blockToRemove);
                            blocks.splice(blocks.indexOf(blockToRemove), 1);
                            if (blockToRemove.userData.chunk) {
                                blockToRemove.userData.chunk.removeBlock(blockToRemove);
                            }
                        }
                    });
                    
                    // Apply placed blocks (add them)
                    worldData.placed.forEach(blockData => {
                        const newBlock = new THREE.Mesh(blockGeometry, getBlockMaterial(blockData.blockType));
                        newBlock.position.set(blockData.x, blockData.y, blockData.z);
                        newBlock.userData.blockType = blockData.blockType;
                        newBlock.userData.isPlayerPlaced = true;
                        newBlock.frustumCulled = true;
                        
                        const { chunkX, chunkZ } = worldToChunk(blockData.x, blockData.z);
                        const chunk = getOrCreateChunk(chunkX, chunkZ);
                        newBlock.userData.chunk = chunk;
                        chunk.addBlock(newBlock);
                        
                        scene.add(newBlock);
                        blocks.push(newBlock);
                    });
                    
                    // Update tracking
                    playerModifications.placed = worldData.placed;
                    playerModifications.removed = worldData.removed;
                    
                    alert(`World data imported! ${worldData.placed.length} blocks placed, ${worldData.removed.length} blocks removed.`);
                } catch (error) {
                    alert('Error importing world data: ' + error.message);
                }
            };
            reader.readAsText(file);
            worldImportInput.value = ''; // Reset input
        });
        
        // Create New World starts the game
        createWorldButton.addEventListener('click', startGame);
        
        function startGame() {
            // Initialize seed before starting game
            initializeSeed();
            document.body.requestPointerLock();
        }

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
            
            // Also hide create world screen when entering game
            if (isPointerLocked) {
                createWorldScreen.style.display = 'none';
                pauseMenu.style.display = 'none'; // Hide pause menu when resuming
            } else if (initialChunksLoaded) {
                // If we're in game and press ESC, show pause menu
                pauseMenu.style.display = 'block';
            }
            
            // Load initial chunks when game starts
            if (isPointerLocked && !initialChunksLoaded) {
                console.log("Generating initial world with seed:", worldSeed);
                updateChunks(0, 0);
                initialChunksLoaded = true;
                console.log(`Loaded ${chunks.size} initial chunks`);
            }
        });
        
        // Click anywhere to re-enter pointer lock after pressing ESC
        document.body.addEventListener('click', (e) => {
            // Don't resume if clicking on pause menu elements
            if (pauseMenu.contains(e.target)) return;
            
            if (!isPointerLocked && initialChunksLoaded) {
                document.body.requestPointerLock();
            }
        });

        // Mouse click handlers for block breaking and placing
        document.addEventListener('mousedown', (e) => {
            if (!isPointerLocked) return;

            if (e.button === 0) { // Left click - break block
                const targetBlock = getTargetBlock();
                if (targetBlock) {
                    // Track removed block for export
                    playerModifications.removed.push({
                        x: targetBlock.position.x,
                        y: targetBlock.position.y,
                        z: targetBlock.position.z
                    });
                    
                    // Broadcast block break to other players
                    broadcastToAll({
                        type: 'blockBreak',
                        x: targetBlock.position.x,
                        y: targetBlock.position.y,
                        z: targetBlock.position.z
                    });
                    
                    scene.remove(targetBlock);
                    const index = blocks.indexOf(targetBlock);
                    if (index > -1) {
                        blocks.splice(index, 1);
                    }
                    // Remove from chunk system
                    if (targetBlock.userData.chunk) {
                        targetBlock.userData.chunk.removeBlock(targetBlock);
                    }
                }
            } else if (e.button === 2) { // Right click - place block
                const targetInfo = getTargetBlockWithFace();
                if (targetInfo) {
                    const { block, face } = targetInfo;
                    const newPos = block.position.clone();
                    
                    // Place block on the face that was clicked
                    if (face === 'top') newPos.y += 1;
                    else if (face === 'bottom') newPos.y -= 1;
                    else if (face === 'left') newPos.x -= 1;
                    else if (face === 'right') newPos.x += 1;
                    else if (face === 'front') newPos.z += 1;
                    else if (face === 'back') newPos.z -= 1;

                    // Check if placing block would collide with player
                    const testPos = player.position.clone();
                    const wouldCollide = 
                        Math.abs(testPos.x - newPos.x) < 0.8 &&
                        Math.abs(testPos.z - newPos.z) < 0.8 &&
                        testPos.y < newPos.y + 0.5 &&
                        testPos.y + player.height > newPos.y - 0.5;

                    if (!wouldCollide) {
                        // Track placed block for export
                        playerModifications.placed.push({
                            x: newPos.x,
                            y: newPos.y,
                            z: newPos.z,
                            blockType: selectedBlockType
                        });
                        
                        // Broadcast block placement to other players
                        broadcastToAll({
                            type: 'blockPlace',
                            x: newPos.x,
                            y: newPos.y,
                            z: newPos.z,
                            blockType: selectedBlockType
                        });
                        
                        const newBlock = new THREE.Mesh(blockGeometry, getBlockMaterial(selectedBlockType));
                        newBlock.position.copy(newPos);
                        newBlock.userData.blockType = selectedBlockType;
                        newBlock.userData.isPlayerPlaced = true;
                        newBlock.frustumCulled = true;
                        
                        // Add to chunk system
                        const { chunkX, chunkZ } = worldToChunk(newPos.x, newPos.z);
                        const chunk = getOrCreateChunk(chunkX, chunkZ);
                        newBlock.userData.chunk = chunk;
                        chunk.addBlock(newBlock);
                        
                        scene.add(newBlock);
                        blocks.push(newBlock);
                    }
                }
            }
        });

        // Prevent context menu on right click
        document.addEventListener('contextmenu', (e) => {
            if (isPointerLocked) e.preventDefault();
        });

        // Raycasting for block selection
        const raycaster = new THREE.Raycaster();
        const maxReachDistance = 5;

        function getTargetBlock() {
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), player.rotation.x);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);

            raycaster.set(camera.position, direction);
            const intersects = raycaster.intersectObjects(blocks);

            if (intersects.length > 0 && intersects[0].distance <= maxReachDistance) {
                return intersects[0].object;
            }
            return null;
        }

        function getTargetBlockWithFace() {
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), player.rotation.x);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);

            raycaster.set(camera.position, direction);
            const intersects = raycaster.intersectObjects(blocks);

            if (intersects.length > 0 && intersects[0].distance <= maxReachDistance) {
                const normal = intersects[0].face.normal;
                let face;
                
                if (normal.y > 0.5) face = 'top';
                else if (normal.y < -0.5) face = 'bottom';
                else if (normal.x > 0.5) face = 'right';
                else if (normal.x < -0.5) face = 'left';
                else if (normal.z > 0.5) face = 'front';
                else if (normal.z < -0.5) face = 'back';

                return { block: intersects[0].object, face };
            }
            return null;
        }

        // Collision detection - OPTIMIZED to only check nearby blocks
        function checkCollision(position) {
            const playerBox = {
                minX: position.x - 0.3,
                maxX: position.x + 0.3,
                minY: position.y,
                maxY: position.y + player.height,
                minZ: position.z - 0.3,
                maxZ: position.z + 0.3
            };

            // OPTIMIZATION: Only check blocks within 5 block radius of player
            // This reduces checks from thousands to ~100 blocks
            const checkRadius = 5;
            for (let block of blocks) {
                // Skip blocks that are far away (quick distance check)
                const dx = Math.abs(block.position.x - position.x);
                const dz = Math.abs(block.position.z - position.z);
                const dy = Math.abs(block.position.y - position.y);
                
                if (dx > checkRadius || dz > checkRadius || dy > checkRadius) {
                    continue; // Skip this block, it's too far
                }
                
                const blockBox = {
                    minX: block.position.x - 0.5,
                    maxX: block.position.x + 0.5,
                    minY: block.position.y - 0.5,
                    maxY: block.position.y + 0.5,
                    minZ: block.position.z - 0.5,
                    maxZ: block.position.z + 0.5
                };

                if (playerBox.maxX > blockBox.minX && playerBox.minX < blockBox.maxX &&
                    playerBox.maxY > blockBox.minY && playerBox.minY < blockBox.maxY &&
                    playerBox.maxZ > blockBox.minZ && playerBox.minZ < blockBox.maxZ) {
                    return true;
                }
            }
            return false;
        }

        function checkGroundCollision() {
            const testPosition = player.position.clone();
            testPosition.y -= 0.1;
            return checkCollision(testPosition);
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            // Update chunks more frequently for better unloading
            // Check every 60 frames (1 second at 60fps) - more frequent than before
            frameCount++;
            if (frameCount % 60 === 0) {
                const dx = Math.abs(player.position.x - lastChunkUpdatePos.x);
                const dz = Math.abs(player.position.z - lastChunkUpdatePos.z);
                // Only update when player moves more than 16 blocks (1 chunk)
                // This ensures chunks unload quickly when you walk away
                if (dx > 16 || dz > 16) {
                    updateChunks(player.position.x, player.position.z);
                    lastChunkUpdatePos.x = player.position.x;
                    lastChunkUpdatePos.z = player.position.z;
                }
            }

            if (isPointerLocked) {
                // Mouse look - smoother with lower sensitivity
                const sensitivity = 0.0012; // Reduced for smoother turning
                player.rotation.y -= mouse.x * sensitivity;
                player.rotation.x -= mouse.y * sensitivity;
                player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
                mouse.x = 0;
                mouse.y = 0;

                // Movement
                const moveSpeed = player.speed * (player.isSprinting ? player.sprintMultiplier : 1);
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);

                let moveX = 0, moveZ = 0;

                if (keys['KeyW']) {
                    moveX += forward.x * moveSpeed;
                    moveZ += forward.z * moveSpeed;
                }
                if (keys['KeyS']) {
                    moveX -= forward.x * moveSpeed;
                    moveZ -= forward.z * moveSpeed;
                }
                if (keys['KeyA']) {
                    moveX -= right.x * moveSpeed;
                    moveZ -= right.z * moveSpeed;
                }
                if (keys['KeyD']) {
                    moveX += right.x * moveSpeed;
                    moveZ += right.z * moveSpeed;
                }

                // Check ground collision
                player.onGround = checkGroundCollision();

                // Jump
                if (keys['Space'] && player.onGround) {
                    player.velocity.y = player.jumpPower;
                }

                // Apply gravity
                if (!player.onGround) {
                    player.velocity.y -= 0.01;
                } else {
                    player.velocity.y = Math.max(0, player.velocity.y);
                }

                // Apply horizontal movement
                const newPosition = player.position.clone();
                newPosition.x += moveX;
                if (!checkCollision(newPosition)) {
                    player.position.x = newPosition.x;
                }

                newPosition.set(player.position.x, player.position.y, player.position.z);
                newPosition.z += moveZ;
                if (!checkCollision(newPosition)) {
                    player.position.z = newPosition.z;
                }

                // Apply vertical movement
                newPosition.set(player.position.x, player.position.y, player.position.z);
                newPosition.y += player.velocity.y;
                if (!checkCollision(newPosition)) {
                    player.position.y = newPosition.y;
                } else {
                    if (player.velocity.y < 0) {
                        player.velocity.y = 0;
                        player.onGround = true;
                    } else {
                        player.velocity.y = 0;
                    }
                }

                // Update camera (Minecraft-style: only pitch and yaw, no roll)
                camera.position.copy(player.position);
                camera.position.y += player.height;
                camera.rotation.order = 'YXZ'; // Yaw, then pitch
                camera.rotation.x = player.rotation.x;
                camera.rotation.y = player.rotation.y;
                camera.rotation.z = 0; // No roll/tilt

                // Update position display
                document.getElementById('position').textContent = 
                    `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
                document.getElementById('seedDisplay').textContent = worldSeed;
                document.getElementById('chunks').textContent = chunks.size;
                document.getElementById('blockCount').textContent = blocks.length;
                
                // Broadcast player position to WebSocket server (if connected)
                frameCount++;
                if (frameCount % 3 === 0) { // Send every 3 frames (~20 times per second)
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        sendWebSocketMessage({
                            type: 'playerMove',
                            x: player.position.x,
                            y: player.position.y,
                            z: player.position.z,
                            rotX: player.rotation.x,
                            rotY: player.rotation.y
                        });
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>